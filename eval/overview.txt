* health
health-1-1：health-revised，两级
health-1-2：health-revised，三级

village与hospital不同组的版本:
health-2-1：health-revised，两级
health-2-2：health-revised，三级

* em3d
共用随机数发生器、随机数关闭：
em3d-1-1：em3d-revised4
em3d-1-2：em3d-revised4
em3d-1-3：em3d-revised4

共用随机数发生器、自行读开启：
em3d-2-1
em3d-2-2
em3d-2-3

每个节点线程用自己的随机数发生器、自行读关闭：
em3d-3-1
em3d-3-2
em3d-3-3 有时会崩溃


节点的度不同。


赋予每个节点一个线程。
初始线程遇到对各个节点computeNewValue的调用，点燃了各个节点线程。
初始线程给每个节点线程添加了很多inovke computeNewValue推测消息。
这些节点线程并行执行各自的computeNewValue方法，对自己的节点值进行更新。
computeNewValue方法在执行的过程中要对所依赖的值进行推测。
这些推测只有当该节点获得确定控制时才能知道推测状态下读到的这些值是对是错。
一旦发现出错，本节点线程提前执行的各个computeNewValue就算是白做了。

另外，节点线程会给其他的节点线程发送推测性的get消息。
这些get消息会掺杂到原本只由inovke computeNewValue组成的消息队列中。
所以，一旦节点线程处理消息的次序出错，提前进行的推测执行也就白做了。

效果不好的原因分析：
启用自行读后，节点线程丢弃effect只发生在发现自己从其他节点读到错误的数值时。
关闭自行读，节点线程更容易验证失败（因为消息的次序）。会重新执行

，推测模式下读的对不对，

em3d-2-1、em3d-2-2、em3d-2-3开启了自行读功能。
为什么开启了自行读之后，有些节点线程就根本没有验证过呢？即ok+fail+empty的总和为0.
更奇怪的是，关闭自行读，共有20个节点线程；开启自行读，共有38个节点线程。
我估计原因是开启之后pc没有调整到，导致执行new两次。那就是40个，为什么是38？

把问题规模放小，以em3d-2-1为例，每个场节点书目设为1或2看看：
无论自行读是否开启
如果我把参数设为每个场1个节点，那么将有2个节点线程。

但是当我把参数设为每个场2个节点后，应该有4个节点线程，但却成了6个节点线程，多出来两个。
但java线程打印时却表明只有4个节点。
(虽失败的推测执行也可能产生新的线程，但em3d应无此问题)

0号一共碰到6次new，0号当时所处模式CSC CSC
如果关闭自行读，0号一共碰到4次new，当时所处模式CCCC。

那些没有验证过的节点线程对应的节点对象，new它们的effect被丢弃了，所以对应的节点对象无效了。
因丢弃而被丢弃的节点对象有：6号，9号。
从profile来看，果然是6号与9号没有验证过。
但是6号和9号线程依然贡献了大量的空闲周期。



* power
power-1-1：power-revised

相比原始程序，除了标记外，对代码没有做任何修改。
其中很多注释已经废弃了，但还没有删除掉，不要被其误导。
用meld将其与原始程序进行对比便可知做了什么改动。

* treeadd
两个版本，相同的输入
treeadd-1-1：treeadd-revised，每个结点独立成组
treeadd-2-1：treeadd-revised3，左右子树各一个组

* tsp
tsp-1-1
